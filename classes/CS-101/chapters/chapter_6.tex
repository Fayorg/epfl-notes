\chapter{Algorithms}

\section{Algorithms}
\begin{definition}[Algorithm]
    An algorithm is a finite sequence of well-defined instructions, typically used to solve a specific task:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item to perform a computation
        \item to solve a certain problem
        \item to reach a certain destination
    \end{itemize}
    In the context of computing the instructions are carried out by a computer.
\end{definition}

\begin{eg}
    Let's find the maximum of a list of numbers:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with the first number as the current maximum.
        \item Compare the current maximum with the next number in the list.
        \item If the next number is greater than the current maximum, update the current maximum to this next number.
        \item Repeat the comparison and update process until all numbers in the list have been checked.
        \item The current maximum at the end of the process is the maximum number in the list.
    \end{itemize}
\end{eg}
Algorithms can be expressed in various ways, including natural language, pseudocode, or programming languages.

\begin{definition}[Pseudocode]
    Pseudocode is a high-level description of an algorithm that uses the structural conventions of programming languages but is intended for human reading rather than machine reading. It combines natural language and programming language elements to outline the logic and steps of an algorithm without adhering to the strict syntax of a specific programming language.
\end{definition}

% TODO: better layout for pseudocode
\begin{eg}
    Here is a pseudocode example for finding the maximum of a list of numbers:
    \begin{algorithmic}
        \Function{max\_finder}{$a_1, a_2, \ldots, a_n$: integers}
            \State $max \gets a_1$
            \For{$i \gets 2$ to $n$}
                \If{$a_i > max$}
                    \State $max \gets a_i$
                \EndIf
            \EndFor
            \State \Return $max$
        \EndFunction
    \end{algorithmic}
\end{eg}
Typically algorithms solve problems such as:
\begin{itemize}[itemsep=1pt,label=$\circ$]
    \item Searching Problems: Finding the position of a particular element in a list
    \item Sorting Problems: Arranging the elements of a list in a certain order (e.g., ascending or descending)
    \item Optimization Problems: Determining the optimal value (maximum or minimum) of a particular quantity over all possible inputs
\end{itemize}

\subsection{Search Algorithms}
\begin{definition}[Search Algorithm]
    A search algorithm is a method used to locate a specific item or group of items within a larger collection of data. The goal of a search algorithm is to efficiently find the desired item(s) while minimizing the time and resources required for the search process.
\end{definition}

\begin{definition}[Linear Search]
    Linear search, also known as sequential search, is a simple search algorithm that checks each element in a list one by one until the desired element is found or the end of the list is reached.
\end{definition}
\begin{eg}
    A linear search algorithm would typically look like this:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item First compare $x$ with the first element of the list.
        \item If they are equal, return the index of the first element.
        \item If not, compare $x$ with the second element of the list.
        \item Repeat this process until either $x$ is found or the end of the list is reached.
        \item If the end of the list is reached without finding $x$, return -1.
    \end{itemize}
    In pseudocode:
    \begin{algorithmic}
        \Function{linear\_search}{$a_1, a_2, \ldots, a_n$: distinct integers, $x$: integer}
            \For{$i \gets 1$ to $n$}
                \If{$a_i = x$}
                    \State \Return $i$
                \EndIf
            \EndFor
            \State \Return $-1$
        \EndFunction
    \end{algorithmic}
\end{eg}
\begin{eg}
    Consider the list $L = (3, 2, -5, 7, 9, 14, 18)$ and $x = 7$. To find the index of $x$ in $L$ using linear search we will need to check $4$ elements: $3, 2, -5, 7$. Let's now compute the average number of comparisons needed to find an element in this list. \\
    Since the list has $7$ elements, the average number of comparisons is:
    \[\frac{1 + 2 + 3 + 4 + 5 + 6 + 7}{7} = \frac{28}{7} = 4\]
    Therefore, on average, we need to check $4$ elements to find an element in the list using linear search. More generally, for a list of size $n$, the average number of comparisons needed to find an element using linear search is:
    \[\frac{1 + 2 + 3 + \ldots + n}{n} = \frac{\frac{n(n+1)}{2}}{n} = \frac{n+1}{2}\]
    Thus, the average number of comparisons needed to find an element in a list of size $n$ using linear search is $\frac{n+1}{2}$.
\end{eg}

\begin{definition}[Binary Search]
    Binary search is an efficient algorithm for finding a specific item in a sorted list. It works by repeatedly dividing the search interval in half, eliminating half of the remaining elements from consideration at each step.
\end{definition}
\begin{eg}
    A binary search algorithm would typically look like this:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with two pointers, one at the beginning of the list (low) and one at the end of the list (high).
        \item Calculate the middle index of the current search interval: $mid = \lfloor (low + high) / 2 \rfloor$.
        \item Compare the middle element with the target value $x$.
        \item If the middle element is equal to $x$, return the index of the middle element.
        \item If $x$ is less than the middle element, update the high pointer to $mid - 1$ to search in the left half of the list.
        \item If $x$ is greater than the middle element, update the low pointer to $mid + 1$ to search in the right half of the list.
        \item Repeat steps 2-6 until either $x$ is found or the low pointer exceeds the high pointer (indicating that $x$ is not in the list).
        \item If $x$ is not found, return -1.
    \end{itemize}
    In pseudocode:
    \begin{algorithmic}
        \Function{binary\_search}{$a_1, a_2, \ldots, a_n$: distinct integers (sorted), $x$: integer}
            \State $low \gets 1$
            \State $high \gets n$
            \While{$low < high$}
                \State $mid \gets \lfloor (low + high) / 2 \rfloor$ \Comment{$\lfloor \cdot \rfloor$ is rounding down}
                \If{$a_{mid} = x$}
                    \State \Return $mid$
                \ElsIf{$a_{mid} \leq x$}
                    \State $low \gets mid + 1$
                \Else
                    \State $high \gets mid - 1$
                \EndIf
            \EndWhile
            \State \Return $-1$
        \EndFunction
    \end{algorithmic}
\end{eg}
\begin{eg}
    Consider the sorted list $L = (2, 3, 5, 7, 9, 14, 18)$ and $x = 5$. To find the index of $x$ in $L$ using binary search we will need to check $3$ elements: $7, 3, 9$.
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item First iteration: $low = 1$, $high = 7$, $mid = \lfloor (1 + 7) / 2 \rfloor = 4$. Compare $a_4 = 7$ with $x = 5$. Since $7 > 5$, we update $high = mid - 1 = 3$.
        \item Second iteration: $low = 1$, $high = 3$, $mid = \lfloor (1 + 3) / 2 \rfloor = 2$. Compare $a_2 = 3$ with $x = 5$. Since $3 < 5$, we update $low = mid + 1 = 3$.
        \item Third iteration: $low = 3$, $high = 3$, $mid = \lfloor (3 + 3) / 2 \rfloor = 3$. Compare $a_3 = 5$ with $x = 5$. They are equal, so we return the index $3$.
    \end{itemize}
    Therefore, the index of $x = 5$ in the list $L$ is $3$.
\end{eg}

% \begin{eg}
%     Consider the sorted list $L = (2, 3, 5, 7, 9, 14, 18)$ and $x = 7$. To find the index of $x$ in $L$ using binary search we will need to check $3$ elements: $7, 3, 9$. Let's now compute the average number of comparisons needed to find an element in this list. \\
%     Since the list has $7$ elements, the average number of comparisons is:
%     \[\frac{1 + 2 + 3}{7} = \frac{6}{7} \approx 0.857\]
%     Therefore, on average, we need to check approximately $0.857$ elements to find an element in the list using binary search. More generally, for a list of size $n$, the average number of comparisons needed to find an element using binary search is:
%     \[\log_2(n)\]
%     Thus, the average number of comparisons needed to find an element in a list of size $n$ using binary search is $\log_2(n)$.
% \end{eg}

\subsection{Sort Algorithms}
\begin{definition}[Sorting Algorithm]
    A sorting algorithm is a method used to arrange the elements of a list or array in a specific order, typically in ascending or descending order. The goal of a sorting algorithm is to efficiently organize the data while minimizing the time and resources required for the sorting process.
\end{definition}

\begin{definition}[Selection Sort]
    Selection sort is a simple sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. The algorithm repeatedly selects the smallest (or largest, depending on the desired order) element from the unsorted sublist and moves it to the end of the sorted sublist until the entire list is sorted.
\end{definition}
\begin{eg}
    A selection sort algorithm would typically look like this:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with the first element of the list as the current minimum.
        \item Compare the current minimum with the next element in the list.
        \item If the next element is smaller than the current minimum, update the current minimum to this next element.
        \item Repeat the comparison and update process until all elements in the unsorted sublist have been checked.
        \item Swap the current minimum with the first element of the unsorted sublist.
        \item Move the boundary between the sorted and unsorted sublists one position to the right.
        \item Repeat steps 1-6 until the entire list is sorted.
    \end{itemize}
    In pseudocode:
    \begin{algorithmic}
        \Function{selection\_sort}{$a_1, a_2, \ldots, a_n$: integers}
            \For{$i \gets 1$ to $n-1$}
                \State $min\_index \gets i$
                \For{$j \gets i+1$ to $n$}
                    \If{$a_j < a_{min\_index}$}
                        \State $min\_index \gets j$
                    \EndIf
                \EndFor
                \State swap($a_i$, $a_{min\_index}$)
            \EndFor
            \State \Return $a_1, a_2, \ldots, a_n$
        \EndFunction
    \end{algorithmic}
\end{eg}
\begin{eg}
    Consider the list $L = (29, 10, 14, 37, 13)$. To sort this list using selection sort we will need to perform the following steps:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item First pass: Find the minimum element in the entire list, which is $10$, and swap it with the first element. The list becomes $(10, 29, 14, 37, 13)$.
        \item Second pass: Find the minimum element in the remaining unsorted sublist $(29, 14, 37, 13)$, which is $13$, and swap it with the second element. The list becomes $(10, 13, 14, 37, 29)$.
        \item Third pass: Find the minimum element in the remaining unsorted sublist $(14, 37, 29)$, which is $14$, and swap it with the third element. The list remains $(10, 13, 14, 37, 29)$.
        \item Fourth pass: Find the minimum element in the remaining unsorted sublist $(37, 29)$, which is $29$, and swap it with the fourth element. The list becomes $(10, 13, 14, 29, 37)$.
        \item The list is now sorted.
    \end{itemize}
    Therefore, after performing selection sort on the list $L = (29, 10, 14, 37, 13)$ we obtain the sorted list $(10, 13, 14, 29, 37)$.
\end{eg}

\begin{eg}
    Let's analyze the number of comparisons made by the selection sort algorithm on a list of size $n$. In the first pass, we compare the first element with the remaining $n-1$ elements, resulting in $n-1$ comparisons. In the second pass, we compare the second element with the remaining $n-2$ elements, resulting in $n-2$ comparisons. This process continues until the second-to-last pass, where we compare the second-to-last element with the last element, resulting in $1$ comparison. The total number of comparisons made by the selection sort algorithm can be calculated as follows:
    \[(n-1) + (n-2) + (n-3) + \ldots + 2 + 1 = \frac{(n-1)n}{2} = \frac{n^2 - n}{2}\]
    Therefore, the selection sort algorithm makes a total of $\frac{n^2 - n}{2}$ comparisons to sort a list of size $n$.
\end{eg}

\begin{definition}[Bubble Sort]
    Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The process is repeated until the list is sorted.
\end{definition}
\begin{eg}
    A bubble sort algorithm would typically look like this:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start at the beginning of the list.
        \item Compare the first two adjacent elements.
        \item If the first element is greater than the second element, swap them.
        \item Move to the next pair of adjacent elements and repeat steps 2-3 until the end of the list is reached.
        \item After each pass through the list, the largest unsorted element will have "bubbled up" to its correct position at the end of the list.
        \item Repeat steps 1-5 for the remaining unsorted portion of the list until no swaps are needed, indicating that the list is sorted.
    \end{itemize}
    In pseudocode:
    \begin{algorithmic}
        \Function{bubble\_sort}{$a_1, a_2, \ldots, a_n$: integers}
            \For{$i \gets 1$ to $n-1$}
                \For{$j \gets 1$ to $n-i$}
                    \If{$a_j > a_{j+1}$}
                        \State swap($a_j$, $a_{j+1}$)
                    \EndIf
                \EndFor
            \EndFor
            \State \Return $a_1, a_2, \ldots, a_n$
        \EndFunction
    \end{algorithmic}
\end{eg}
\begin{eg}
    Consider the list $L = (5, 1, 4, 2, 8)$. To sort this list using bubble sort we will need to perform the following steps:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item First pass: Compare $5$ and $1$, swap them. List becomes $(1, 5, 4, 2, 8)$. Compare $5$ and $4$, swap them. List becomes $(1, 4, 5, 2, 8)$. Compare $5$ and $2$, swap them. List becomes $(1, 4, 2, 5, 8)$. Compare $5$ and $8$, no swap needed. End of first pass.
        \item Second pass: Compare $1$ and $4$, no swap needed. Compare $4$ and $2$, swap them. List becomes $(1, 2, 4, 5, 8)$. Compare $4$ and $5$, no swap needed. End of second pass.
        \item Third pass: Compare $1$ and $2$, no swap needed. Compare $2$ and $4$, no swap needed. End of third pass.
        \item The list is now sorted.
    \end{itemize}
    Therefore, after performing bubble sort on the list $L = (5, 1, 4, 2, 8)$ we obtain the sorted list $(1, 2, 4, 5, 8)$.
\end{eg}
\begin{eg}
    Let's analyze the number of comparisons made by the bubble sort algorithm on a list of size $n$. In the first pass, we compare the first element with the second element, then the second element with the third element, and so on, until we compare the $(n-1)$-th element with the $n$-th element. This results in $n-1$ comparisons. In the second pass, we again compare adjacent elements, but this time we only need to compare up to the $(n-2)$-th element, resulting in $n-2$ comparisons. This process continues until the second-to-last pass, where we compare only the first two elements, resulting in $1$ comparison. The total number of comparisons made by the bubble sort algorithm can be calculated as follows:
    \[(n-1) + (n-2) + (n-3) + \ldots + 2 + 1 = \frac{(n-1)n}{2} = \frac{n^2 - n}{2}\]
    Therefore, the bubble sort algorithm makes a total of $\frac{n^2 - n}{2}$ comparisons to sort a list of size $n$.
\end{eg}

\subsection{Greedy Algorithms}
\begin{definition}[Greedy Algorithm]
    A greedy algorithm is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit or the most optimal choice at that moment. The idea is to make a series of choices, each of which looks best at the time, with the hope that these local optimum choices will lead to a global optimum solution.
\end{definition}

\begin{eg}
    Let the graph below represent cities (nodes) connected by roads (edges) with weights representing distances between cities. We want to find the shortest path from city A to city F.
    \begin{center}
        \begin{tikzpicture}
            % Nodes
            \node[circle, draw] (A) at (0, 0) {A};
            \node[circle, draw] (B) at (2, 2) {B};
            \node[circle, draw] (C) at (2.3, 0) {C};
            \node[circle, draw] (D) at (2, -2) {D};
            \node[circle, draw] (F) at (4, 1) {F};
            \node[circle, draw] (E) at (4, -1) {E};

            % Edges with weights
            \draw (A) -- (B) node[midway, above] {9};
            \draw (A) -- (C) node[midway, above] {9};
            \draw (A) -- (D) node[midway, below left] {7};
            \draw (B) -- (C) node[midway, right] {2};
            \draw (C) -- (D) node[midway, left] {1};
            \draw (B) -- (F) node[midway, above] {9};
            \draw (C) -- (E) node[midway, below left] {11};
            \draw (D) -- (E) node[midway, below right] {15};
            \draw (E) -- (F) node[midway, right] {6};

            % Highlight the shortest path
            \draw[thick, primary] (A) -- (D);
            \draw[thick, primary] (D) -- (C);
            \draw[thick, primary] (C) -- (B);
            \draw[thick, primary] (B) -- (F);
        \end{tikzpicture}
    \end{center}
    Following the approach of a Greedy algorithm we get:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item From A, the closest city is D (distance 7).
        \item From D, the closest city is C (distance 1).
        \item From C, the closest city is B (distance 2).
        \item From B, the closest city is F (distance 9).
    \end{itemize}
    The path taken is A → D → C → B → F with a total distance of 7 + 1 + 2 + 9 = 19. \\
    Note that this greedy approach does not always yield the optimal solution for all graphs, like in this case where the optimal path A → B → F has a total distance of 18.
\end{eg}

\begin{eg}[Cashier's Algorithm]
    Find for an amount of any $n$ cents the least total number of coins using the following coins: quarters (25 cents), dimes (10 cents), nickels (5 cents), and pennies (1 cent). A greedy algorithm for this problem would look like this:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with the total amount of cents, $n$.
        \item While $n$ is greater than 0:
        \begin{itemize}[itemsep=1pt,label=$\circ$]
            \item If $n$ is greater than or equal to 25, subtract 25 from $n$ and add a quarter to the coin count.
            \item Else if $n$ is greater than or equal to 10, subtract 10 from $n$ and add a dime to the coin count.
            \item Else if $n$ is greater than or equal to 5, subtract 5 from $n$ and add a nickel to the coin count.
            \item Else, subtract 1 from $n$ and add a penny to the coin count.
        \end{itemize}
        \item Return the total coin count.
    \end{itemize}
    In pseudocode:
    \begin{algorithmic}
        \Function{cashier\_algorithm}{$n$: integer (amount in cents)}
            \State $coin\_count \gets 0$
            \While{$n > 0$}
                \If{$n \geq 25$}
                    \State $n \gets n - 25$
                    \State $coin\_count \gets coin\_count + 1$
                \ElsIf{$n \geq 10$}
                    \State $n \gets n - 10$
                    \State $coin\_count \gets coin\_count + 1$
                \ElsIf{$n \geq 5$}
                    \State $n \gets n - 5$
                    \State $coin\_count \gets coin\_count + 1$
                \Else
                    \State $n \gets n - 1$
                    \State $coin\_count \gets coin\_count + 1$
                \EndIf
            \EndWhile
            \State \Return $coin\_count$
        \EndFunction
    \end{algorithmic}
    For example, if we want to make change for 63 cents, the algorithm would proceed as follows:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with $n = 63$.
        \item Subtract 25 (quarter), $n = 38$, coin count = 1.
        \item Subtract 25 (quarter), $n = 13$, coin count = 2.
        \item Subtract 10 (dime), $n = 3$, coin count = 3.
        \item Subtract 1 (penny), $n = 2$, coin count = 4.
        \item Subtract 1 (penny), $n = 1$, coin count = 5.
        \item Subtract 1 (penny), $n = 0$, coin count = 6.
    \end{itemize}
    The total number of coins used is 6 (2 quarters, 1 dime, and 3 pennies).
\end{eg}

\begin{theorem}
    The cashier's algorithm always produces the optimal solution when the coin denominations are 25 cents, 10 cents, 5 cents, and 1 cent (USA).
\end{theorem}
\begin{proof}
    Let's prove that the cashier's algorithm always produces the optimal solution for any amount of cents $n$ using the denominations of 25 cents (quarters), 10 cents (dimes), 5 cents (nickels), and 1 cent (pennies). Let $q$ be the number of quarters, $d$ be the number of dimes, $n$ be the number of nickels, and $c$ be the number of cents. Let $(\hat{q}, \hat{d}, \hat{n}, \hat{c})$ be the solution produced by the cashier's algorithm and $(q, d, n, c)$ be the optimal solution. For any amount of cents $s$, we have:
    \[25\hat{q} + 10\hat{d} + 5\hat{n} + \hat{c} = s = 25q + 10d + 5n + c\]
    For any solution to be optimal, it must satisfy the following conditions:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $\hat{c} < 5$ (otherwise we could replace 5 cents with a nickel)
        \item $\hat{n} < 2$ (otherwise we could replace 2 nickels with a dime)
        \item $\hat{d} < 3$ (otherwise we could replace 3 dimes with a quarter)
    \end{itemize}
    Otherwise we could always reduce the number of coins used by replacing 5 cents with a nickel, 2 nickels with a dime, or 3 dimes with a quarter:
    \[
        (q, d, n, c) \ \text{where } n \geq 2 \implies (q, d + 1, n - 2, c) \ \text{a better solution}
    \]
    \[
        (q, d, n, c) \ \text{where } c \geq 5 \implies (q, d, n + 1, c - 5) \ \text{a better solution}
    \]
    \[
        (q, d, n, c) \ \text{where } d \geq 3 \implies (q + 1, d - 3, n, c) \ \text{a better solution}
    \]
    And we know that the greedy solution $(\hat{q}, \hat{d}, \hat{n}, \hat{c})$ satisfies these conditions. We now have:
    \[q \leq \hat{q}\]
    Let's consider the case where $q = \hat{q} - 1$. Then we have:
    \[10d + 5n + c = 25 + 10\hat{d} + 5\hat{n} + \hat{c}\]
    Since $c < 5$, $\hat{c} < 5$, $n < 2$, and $\hat{n} < 2$, we must have $d \geq \hat{d} + 3$, which contradicts the optimality of $(q, d, n, c)$. Therefore, we must have $q = \hat{q}$. Similarly, we can show that $d = \hat{d}$, $n = \hat{n}$, and $c = \hat{c}$. Thus, the solution produced by the cashier's algorithm is indeed optimal for any amount of cents $n$ using the denominations of 25 cents, 10 cents, 5 cents, and 1 cent.
    % \[10\hat{d} + 5\hat{n} + \hat{c} = s = 10d + 5n + c\]
    % For any solution to be optimal, it must satisfy the following conditions:
    % \begin{itemize}[itemsep=1pt,label=$\circ$]
    %     \item $\hat{c} < 5$ (otherwise we could replace 5 cents with a nickel)
    %     \item $\hat{n} < 2$ (otherwise we could replace 2 nickels with a dime)
    % \end{itemize}
    % Otherwise we could always reduce the number of coins used by replacing 5 cents with a nickel or 2 nickels with a dime:
    % \[
    %     (d, n, c) \ \text{where } n \geq 2 \implies (d + 1, n - 2, c) \ \text{a better solution}
    % \]
    % \[
    %     (d, n, c) \ \text{where } c \geq 5 \implies (d, n + 1, c - 5) \ \text{a better solution}
    % \]
    % And we know that the greedy solution $(\hat{d}, \hat{n}, \hat{c})$ satisfies these conditions. We now have:
    % \[
    %     d \leq \hat{d}
    % \]
    % Let's consider the case where $d = \hat{d} - 1$. Then we have:
    % \[5n + c = 10 + 5\hat{n} + \hat{c}\]
    % Since $c < 5$ and $\hat{c} < 5$, we must have $n \geq \hat{n} + 2$, which contradictss the optimality of $(d, n, c)$. Therefore, we must have $d = \hat{d}$. Similarly, we can show that $n = \hat{n}$ and $c = \hat{c}$. Thus, the solution produced by the cashier's algorithm is indeed optimal for any amount of cents $n$ using the denominations of 10 cents, 5 cents, and 1 cent.
\end{proof}

\begin{eg}
    If you apply Cashier's algorithm to make change for 31 cents with only quarters (25 cents), dimes (10 cents), and pennies (1 cent), the algorithm would proceed as follows:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item Start with $n = 31$.
        \item Subtract 25 (quarter), $n = 6$, coin count = 1.
        \item Subtract 1 (penny) 6 times, $n = 0$, coin count = 7.
    \end{itemize}
    The total number of coins used is 7 (1 quarter and 6 pennies). However, the optimal solution would be to use 3 dimes and 1 penny, which totals to 4 coins. This example illustrates that Cashier's algorithm does not always yield the optimal solution when the coin denominations changes.
\end{eg}
There is no simple formula for assessing, whether for a given set of coin denominations, Cashier's algorithm always produces an optimal solution.

\subsection{Matching Algorithm}
\begin{definition}[Matchings]
    Given a finite set $A$, a matching of $A$ is a set of (unordered) pairs of distinct elements of $A$ where any element occurs in at most one pair (such pairs are called independent).    
\end{definition}

\begin{definition}[Maximum Matching]
    A maximum matching is a matching that contains the largest possible number of independent pairs.
\end{definition}

\begin{eg}
    Let $A = \{\text{Lou}, \text{Glenn}, \text{Bobbie}, \text{Jenny}, \text{Tyler}\}$. Then:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $\{(\text{Lou}, \text{Glenn})\}$ is a matching of $A$.
        \item $\{(\text{Lou}, \text{Lou})\}$ is not a matching of $A$.
        \item $\{(\text{Lou}, \text{Glenn}), (\text{Lou}, \text{Tyler})\}$ is not a matching of $A$.
        \item $\{(\text{Lou}, \text{Glenn}), (\text{Bobbie}, \text{Jenny})\}$ is a matching of $A$.
    \end{itemize}
\end{eg}

\begin{definition}[Preference List]
    A preference list $L_x$ defines for every element $x \in A$ the order in which the element prefers to be paired with another element. $x$ prefers $y$ over $z$ if $y$ precedes $z$ on $L_x$.
\end{definition}
\begin{eg}
    Let $A = \{\text{Lou}, \text{Glenn}, \text{Bobbie}, \text{Tyler}\}$ with the following preference lists:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $L_{\text{Lou}} = [\text{Glenn}, \text{Bobbie}, \text{Tyler}]$
        \item $L_{\text{Glenn}} = [\text{Bobbie}, \text{Lou}, \text{Tyler}]$
        \item $L_{\text{Bobbie}} = [\text{Lou}, \text{Glenn}, \text{Tyler}]$
        \item $L_{\text{Tyler}} = [\text{Lou}, \text{Glenn}, \text{Bobbie}]$
    \end{itemize}
\end{eg}

\begin{definition}[Stable Matching]
    A matching is stable if there are no two elements $x$ and $y$ that are not paired with each other but prefer each other over their current partners.
\end{definition}

\begin{eg}
    Let $A = \{\text{Lou}, \text{Glenn}, \text{Bobbie}, \text{Tyler}\}$ with the following preference lists:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $L_{\text{Lou}} = [\text{Glenn}, \text{Bobbie}, \text{Tyler}]$
        \item $L_{\text{Glenn}} = [\text{Bobbie}, \text{Lou}, \text{Tyler}]$
        \item $L_{\text{Bobbie}} = [\text{Lou}, \text{Glenn}, \text{Tyler}]$
        \item $L_{\text{Tyler}} = [\text{Lou}, \text{Glenn}, \text{Bobbie}]$
    \end{itemize}
    Consider the matchings:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $M_1 = \{(\text{Lou}, \text{Tyler}), (\text{Glenn}, \text{Bobbie})\}$ is an unstable matching because Lou prefers Bobbie over Tyler, and Bobbie prefers Lou over Glenn.
        \item $M_2 = \{(\text{Lou}, \text{Bobbie}), (\text{Glenn}, \text{Tyler})\}$ is a stable matching because there are no two elements that prefer each other over their current partners.
    \end{itemize}
\end{eg}

\begin{definition}[Matching Function]
    Given a set with even cardinality, partition $A$ into two disjoint subsets $A_1$ and $A_2$, with $A_1 \cup A_2 = A$ and $|A_1| = |A_2|$. A matching is a bijection from the elements of one set to the elements of the other set. That means, that pairs can only consist of one element of $A_1$ and one element of $A_2$.
\end{definition}

\begin{definition}[Marriage Problem]
    The marriage problem is to find a stable matching for a given set $A$ with even cardinality and preference lists for each element in $A$.
\end{definition}

\begin{eg}
    Let $A_1 = \{\text{Lou}, \text{Glenn}\}$ and $A_2 = \{\text{Jenny}, \text{Tyler}\}$. Then the preference lists are:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item $L_{\text{Lou}} = [\text{Jenny}, \text{Tyler}]$
        \item $L_{\text{Glenn}} = [\text{Jenny}, \text{Tyler}]$
        \item $L_{\text{Jenny}} = [\text{Lou}, \text{Glenn}]$
        \item $L_{\text{Tyler}} = [\text{Lou}, \text{Glenn}]$
    \end{itemize}
    We can make a graph to represent matchings possibility:
    \begin{center}
        \begin{tikzpicture}
            % Nodes
            \node[circle, fill, inner sep=1.5pt] (Lou) at (0, 1) {};
            \node[circle, fill, inner sep=1.5pt] (Glenn) at (0, 0) {};
            \node[circle, fill, inner sep=1.5pt] (Jenny) at (2, 1) {};
            \node[circle, fill, inner sep=1.5pt] (Tyler) at (2, 0) {};

            % Labels
            \node at (Lou) [left=5pt] {Lou};
            \node at (Glenn) [left=5pt] {Glenn};
            \node at (Jenny) [right=5pt] {Jenny};
            \node at (Tyler) [right=5pt] {Tyler};

            % Edges
            \draw[thick,primary] (Lou) -- (Jenny);
            \draw[thick,secondary] (Lou) -- (Tyler);
            \draw[thick,secondary] (Glenn) -- (Jenny);
            \draw[thick,primary] (Glenn) -- (Tyler);
        \end{tikzpicture}
    \end{center}
    The edges in the \textcolor{primary}{primary} color represent the pairs in the stable matching while the edges in the \textcolor{secondary}{secondary} color represent the pairs not in the stable matching.
\end{eg}

\begin{definition}[Gale-Shapley Algorithm]
    The Gale-Shapley algorithm is a method for finding a stable matching in the marriage problem. The algorithm works as follows:
    \begin{itemize}[itemsep=1pt,label=$\circ$]
        \item \textbf{Proposals:} Each man proposes to women in order of their preferences.
        \item \textbf{Acceptance and Rejection:}
        \begin{itemize}[itemsep=1pt,label=$\circ$]
            \item If a woman is free, she provisionally accepts the proposal.
            \item If she is already engaged, she compares the new proposal with her current engagement. 
            \item If she prefers the new proposal, she accepts it and rejects her current engagement. 
            \item Otherwise, she rejects the new proposal.
        \end{itemize}
        \item \textbf{Continue the Process:} Any man who is rejected proposes to the next woman on his list.
        \item \textbf{Termination:} The process continues until every man is engaged.
    \end{itemize}
    The algorithm guarantees that the resulting matching is stable, the result is optimal for the side that proposes and the algorithm is deterministic (always produces the same output for the same input).
\end{definition}